"""
TSA Independent Verifier
=========================
A standalone library for verifying RFC 3161 timestamp tokens.

This library allows anyone to independently verify timestamp tokens
without relying on the original timestamping service.

Copyright (c) 2025 - Open Source
License: MIT
"""

import base64
import json
import logging
from typing import Dict, Optional, Union
from pathlib import Path
from tsp_client import TSPVerifier

# Known TSA Providers - synchronized with the timestamping service
KNOWN_TSA_PROVIDERS = {
    "FreeTSA": {
        "name": "FreeTSA",
        "url": "https://freetsa.org/tsr",
        "priority": 1,
        "description": "Free Time Stamping Authority"
    },
    "SafeCreative": {
        "name": "SafeCreative",
        "url": "https://tsa.safecreative.org",
        "priority": 2,
        "description": "SafeCreative TSA Service"
    },
    "OpenTimestamps": {
        "name": "OpenTimestamps",
        "url": "https://alice.btc.calendar.opentimestamps.org",
        "priority": 3,
        "description": "Bitcoin-based Timestamp Service"
    },
    "Sectigo": {
        "name": "Sectigo",
        "url": "http://timestamp.sectigo.com/qualified",
        "priority": 4,
        "description": "Sectigo Qualified Timestamp Service"
    },
    "SSL": {
        "name": "SSL",
        "url": "http://timestamp.digicert.com",
        "priority": 5,
        "description": "DigiCert Timestamp Service"
    },
    "GlobalSign": {
        "name": "GlobalSign",
        "url": "http://timestamp.globalsign.com/tsa/v3",
        "priority": 6,
        "description": "GlobalSign TSA Service"
    },
    "Apple": {
        "name": "Apple",
        "url": "http://timestamp.apple.com/ts01",
        "priority": 7,
        "description": "Apple Timestamp Service"
    },
    "Microsoft": {
        "name": "Microsoft",
        "url": "http://timestamp.microsoft.com/scripts/timstamp.dll",
        "priority": 8,
        "description": "Microsoft Timestamp Service"
    },
    "CEV": {
        "name": "CEV",
        "url": "https://tsa.cev.be/tsawebservice",
        "priority": 9,
        "description": "CEV Belgium TSA Service"
    },
    "Intesi": {
        "name": "Intesi",
        "url": "http://tsa.time4mind.com/timestamp",
        "priority": 10,
        "description": "Intesi Group TSA Service"
    },
    "TrueTimestamp": {
        "name": "TrueTimestamp",
        "url": "https://truetimestamp.org/timestamp",
        "priority": 11,
        "description": "TrueTimestamp Service"
    },
    "Sigstore": {
        "name": "Sigstore",
        "url": "https://timestamp.sigstore.dev/timestamp",
        "priority": 12,
        "description": "Sigstore Timestamp Service"
    },
    "Identrust": {
        "name": "Identrust",
        "url": "http://timestamp.identrust.com",
        "priority": 13,
        "description": "IdenTrust Timestamp Service"
    }
}


class IndependentTSAVerifier:
    """
    Independent timestamp token verifier.

    This class provides methods to verify RFC 3161 timestamp tokens
    generated by any TSA (Time Stamping Authority) provider.
    """

    def __init__(self, debug: bool = False):
        """
        Initialize the verifier.

        Args:
            debug: Enable debug logging
        """
        self.logger = logging.getLogger(__name__)
        if debug:
            logging.basicConfig(
                level=logging.DEBUG,
                format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
            )
        else:
            logging.basicConfig(level=logging.INFO)

    def verify_from_tsr_file(
            self,
            tsr_file_path: str,
            original_hash: str,
            provider_name: str
    ) -> Dict:
        """
        Verify a timestamp from a .tsr file.

        This is the most common use case: users have a .tsr file downloaded
        from the timestamping service, along with the document hash and
        provider name.

        Args:
            tsr_file_path: Path to the .tsr file (timestamp token)
            original_hash: SHA-256 hash of the original document
            provider_name: Name of the TSA provider (e.g., "SSL", "FreeTSA")

        Returns:
            Dict with verification results

        Example:
            verifier = IndependentTSAVerifier()
            result = verifier.verify_from_tsr_file(
                tsr_file_path="document.tsr",
                original_hash="2f94444c1fe84c7f161159ebfd550e6bab1eaa285dd3a759f3e1e5f841624656",
                provider_name="SSL"
            )
        """
        try:
            self.logger.info(f"Verifying timestamp from file: {tsr_file_path}")

            # Validate provider
            provider_info = self._validate_provider(provider_name)

            # Read the .tsr file
            tsr_path = Path(tsr_file_path)
            if not tsr_path.exists():
                return {
                    "valid": False,
                    "error": f"File not found: {tsr_file_path}",
                    "details": "The .tsr file does not exist at the specified path"
                }

            with open(tsr_path, 'rb') as f:
                timestamp_token = f.read()

            self.logger.info(f"Loaded {len(timestamp_token)} bytes from {tsr_file_path}")

            # Verify the timestamp
            result = self.verify_timestamp_token(
                timestamp_token=timestamp_token,
                original_hash=original_hash,
                provider_name=provider_name
            )

            # Add provider information
            if result.get('valid'):
                result['provider_info'] = provider_info

            return result

        except Exception as e:
            self.logger.error(f"Error reading .tsr file: {str(e)}")
            return {
                "valid": False,
                "error": f"Failed to read .tsr file: {str(e)}",
                "details": "Ensure the file is a valid timestamp token (.tsr) file"
            }

    def verify_timestamp_token(
            self,
            timestamp_token: bytes,
            original_hash: str,
            provider_name: Optional[str] = None
    ) -> Dict:
        """
        Verify a timestamp token against the original data hash.

        This is the core verification method that uses cryptographic
        verification to ensure:
        1. The timestamp token is valid and signed by a trusted TSA
        2. The token corresponds to the provided hash
        3. The token hasn't been tampered with

        Args:
            timestamp_token: The RFC 3161 timestamp token (bytes)
            original_hash: The SHA-256 hash of the original data
            provider_name: Optional name of the TSA provider (for reference)

        Returns:
            Dict with verification results
        """
        try:
            self.logger.info("=" * 70)
            self.logger.info("STARTING INDEPENDENT TIMESTAMP VERIFICATION")
            self.logger.info("=" * 70)
            self.logger.debug(f"Document Hash: {original_hash}")
            self.logger.debug(f"Token Size: {len(timestamp_token)} bytes")

            if provider_name:
                provider_info = self._validate_provider(provider_name)
                self.logger.info(f"Provider: {provider_info['name']} ({provider_info['url']})")

            # Initialize the TSP verifier
            verifier = TSPVerifier()

            # Verify the timestamp token
            self.logger.info("Verifying cryptographic signature...")
            verified = verifier.verify(
                timestamp_token,
                message=original_hash.encode('utf-8')
            )

            if verified is None:
                self.logger.error("❌ Verification failed: Invalid token signature")
                return {
                    "valid": False,
                    "verification_status": "FAILED",
                    "error": "Token verification failed - invalid signature or structure",
                    "details": "The timestamp token signature could not be verified. The token may be corrupted, tampered with, or not signed by a trusted TSA.",
                    "original_hash": original_hash,
                    "provider": provider_name
                }

            # Extract timestamp information
            tst_info = verified.tst_info

            if tst_info is None:
                self.logger.error("❌ No timestamp info found in token")
                return {
                    "valid": False,
                    "verification_status": "FAILED",
                    "error": "No timestamp info found in token",
                    "details": "The token structure is invalid or incomplete.",
                    "original_hash": original_hash,
                    "provider": provider_name
                }

            # Build verification result
            self.logger.info("✓ Cryptographic signature verified successfully")
            self.logger.info("✓ Hash matches timestamp token")
            self.logger.info("=" * 70)
            self.logger.info(f"✓ Timestamp: {tst_info.get('gen_time', 'Unknown')}")
            self.logger.info(f"✓ TSA Authority: {tst_info.get('tsa', 'Unknown')}")
            self.logger.info(f"✓ Serial Number: {tst_info.get('serial_number', 'Unknown')}")
            self.logger.info("=" * 70)

            result = {
                "valid": True,
                "verification_status": "VERIFIED",
                "timestamp": str(tst_info.get('gen_time', 'Unknown')),
                "tsa_authority": str(tst_info.get('tsa', 'Unknown')),
                "serial_number": str(tst_info.get('serial_number', 'Unknown')),
                "policy": str(tst_info.get('policy', 'Unknown')),
                "accuracy": str(tst_info.get('accuracy', 'Unknown')),
                "hash_algorithm": "SHA-256",
                "hash_verified": True,
                "original_hash": original_hash,
                "token_size_bytes": len(timestamp_token),
                "message": "✓ This timestamp has been independently verified and is authentic"
            }

            if provider_name:
                result["provider"] = provider_name

            return result

        except Exception as e:
            self.logger.error(f"❌ Error during verification: {str(e)}", exc_info=True)
            return {
                "valid": False,
                "verification_status": "ERROR",
                "error": str(e),
                "details": "An unexpected error occurred during verification. Check the token format and hash.",
                "original_hash": original_hash,
                "provider": provider_name
            }

    def _validate_provider(self, provider_name: str) -> Dict:
        """
        Validate and get information about a TSA provider.

        Args:
            provider_name: Name of the provider

        Returns:
            Dict with provider information
        """
        if provider_name not in KNOWN_TSA_PROVIDERS:
            self.logger.warning(f"⚠ Provider '{provider_name}' not in known providers list")
            return {
                "name": provider_name,
                "url": "Unknown",
                "description": "Unknown TSA Provider",
                "is_known": False
            }

        provider = KNOWN_TSA_PROVIDERS[provider_name].copy()
        provider["is_known"] = True
        return provider

    def list_providers(self) -> list:
        """
        List all known TSA providers.

        Returns:
            List of provider information dictionaries
        """
        return sorted(
            KNOWN_TSA_PROVIDERS.values(),
            key=lambda x: x['priority']
        )

    def verify_from_json_file(self, json_file_path: str) -> Dict:
        """
        Verify a timestamp from a JSON file.

        Expected JSON format:
        {
            "hash": "sha256_hash_string",
            "timestamp_token": "base64_encoded_token" or {"$binary": {"base64": "..."}},
            "provider": "ProviderName"
        }

        Args:
            json_file_path: Path to the JSON file

        Returns:
            Dict with verification results
        """
        try:
            self.logger.info(f"Reading verification data from: {json_file_path}")

            with open(json_file_path, 'r') as f:
                data = json.load(f)

            return self.verify_from_dict(data)

        except FileNotFoundError:
            return {
                "valid": False,
                "error": f"File not found: {json_file_path}"
            }
        except json.JSONDecodeError as e:
            return {
                "valid": False,
                "error": f"Invalid JSON format: {str(e)}"
            }
        except Exception as e:
            return {
                "valid": False,
                "error": f"Error reading file: {str(e)}"
            }

    def verify_from_dict(self, data: Dict) -> Dict:
        """
        Verify a timestamp from a dictionary.

        Args:
            data: Dictionary containing 'hash', 'timestamp_token', and optionally 'provider'

        Returns:
            Dict with verification results
        """
        try:
            # Extract hash
            original_hash = data.get('hash')
            if not original_hash:
                return {
                    "valid": False,
                    "error": "Missing 'hash' field in data"
                }

            # Extract timestamp token
            token_data = data.get('timestamp_token')
            if not token_data:
                return {
                    "valid": False,
                    "error": "Missing 'timestamp_token' field in data"
                }

            # Decode token based on format
            timestamp_token = self._decode_token(token_data)

            # Extract provider (optional)
            provider = data.get('provider')

            # Verify
            return self.verify_timestamp_token(
                timestamp_token=timestamp_token,
                original_hash=original_hash,
                provider_name=provider
            )

        except Exception as e:
            self.logger.error(f"Error processing data: {str(e)}")
            return {
                "valid": False,
                "error": str(e)
            }

    def _decode_token(self, token_data: Union[str, Dict, bytes]) -> bytes:
        """
        Decode timestamp token from various formats.

        Args:
            token_data: Token in base64 string, MongoDB binary dict, or bytes

        Returns:
            Decoded token as bytes
        """
        # Handle MongoDB binary format
        if isinstance(token_data, dict):
            if '$binary' in token_data:
                token_base64 = token_data['$binary'].get('base64', '')
            elif 'base64' in token_data:
                token_base64 = token_data['base64']
            else:
                raise ValueError("Invalid token dictionary format")

            return base64.b64decode(token_base64)

        # Handle base64 string
        elif isinstance(token_data, str):
            try:
                return base64.b64decode(token_data)
            except Exception as e:
                raise ValueError(f"Invalid base64 token string: {str(e)}")

        # Handle bytes
        elif isinstance(token_data, (bytes, bytearray)):
            return bytes(token_data)

        else:
            raise ValueError(f"Unsupported token type: {type(token_data).__name__}")

    def compare_with_original_verification(
            self,
            verification_data: Dict,
            original_verified: bool
    ) -> Dict:
        """
        Compare independent verification with original system verification.

        Args:
            verification_data: Result from verify_from_dict or verify_from_tsr_file
            original_verified: The 'verified' status from the original system

        Returns:
            Dict with comparison results
        """
        independent_valid = verification_data.get('valid', False)

        match = independent_valid == original_verified

        return {
            "independent_verification": independent_valid,
            "original_verification": original_verified,
            "results_match": match,
            "confidence": "HIGH" if match else "MISMATCH",
            "trust_level": "VERIFIED" if match else "DISPUTED",
            "note": (
                "✓ Independent verification confirms original system verification."
                if match
                else "⚠ WARNING: Independent verification does not match original system! Investigate further."
            )
        }


def print_verification_result(result: Dict, verbose: bool = False) -> None:
    """
    Print verification result in a human-readable format.

    Args:
        result: Verification result dictionary
        verbose: Show detailed information
    """
    print("\n" + "=" * 80)
    print(" " * 20 + "INDEPENDENT TIMESTAMP VERIFICATION RESULT")
    print("=" * 80)

    if result.get('valid', False):
        print("\n✓✓✓ STATUS: VERIFIED AND AUTHENTIC ✓✓✓\n")
        print(f"  Timestamp:        {result.get('timestamp', 'Unknown')}")
        print(f"  TSA Authority:    {result.get('tsa_authority', 'Unknown')}")
        print(f"  Serial Number:    {result.get('serial_number', 'Unknown')}")

        if 'provider' in result:
            print(f"  Provider:         {result['provider']}")

        if verbose:
            print(f"\n  Additional Details:")
            print(f"  ─────────────────────────────────────────────────────")
            print(f"  Policy OID:       {result.get('policy', 'Unknown')}")
            print(f"  Accuracy:         {result.get('accuracy', 'Unknown')}")
            print(f"  Hash Algorithm:   {result.get('hash_algorithm', 'SHA-256')}")
            print(f"  Token Size:       {result.get('token_size_bytes', 'Unknown')} bytes")
            print(f"  Document Hash:    {result.get('original_hash', 'Unknown')[:64]}...")

        if 'provider_info' in result and result['provider_info'].get('is_known'):
            print(f"\n  Provider Details:")
            print(f"  ─────────────────────────────────────────────────────")
            print(f"  Name:             {result['provider_info']['name']}")
            print(f"  URL:              {result['provider_info']['url']}")
            print(f"  Description:      {result['provider_info']['description']}")

        print("\n" + "─" * 80)
        print("  VERIFICATION RESULT:")
        print("  ✓ This timestamp has been independently verified")
        print("  ✓ The document existed at the stated time")
        print("  ✓ The document has not been altered since timestamping")
        print("  ✓ The cryptographic signature is valid")
        print("─" * 80)

    else:
        print("\n✗✗✗ STATUS: VERIFICATION FAILED ✗✗✗\n")
        print(f"  Error: {result.get('error', 'Unknown error')}")

        if 'details' in result:
            print(f"\n  Details:")
            print(f"  {result['details']}")

        if 'original_hash' in result:
            print(f"\n  Document Hash: {result['original_hash']}")

        if 'provider' in result:
            print(f"  Provider: {result['provider']}")

        print("\n" + "─" * 80)
        print("  POSSIBLE CAUSES:")
        print("  • The timestamp token may be corrupted")
        print("  • The hash does not match the token")
        print("  • The token was not signed by a trusted TSA")
        print("  • The file format is incorrect")
        print("─" * 80)

    print("=" * 80 + "\n")


def print_provider_list():
    """Print list of known TSA providers."""
    print("\n" + "=" * 80)
    print(" " * 25 + "KNOWN TSA PROVIDERS")
    print("=" * 80)
    print(f"\n{'Priority':<10} {'Name':<20} {'URL':<50}")
    print("─" * 80)

    for provider in sorted(KNOWN_TSA_PROVIDERS.values(), key=lambda x: x['priority']):
        print(f"{provider['priority']:<10} {provider['name']:<20} {provider['url']:<50}")

    print("=" * 80 + "\n")

